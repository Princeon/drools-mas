/*
 * Copyright 2011 JBoss Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
    Message content processing.
    Determines the actions necessary to handle a message
    The actions will be executed on a target session, as decided by the routing rules
*/

package org.drools.mas;
import org.drools.mas.ACLMessage;
import org.drools.runtime.StatefulKnowledgeSession;
import org.drools.command.CommandFactory;
import org.drools.command.BatchExecutionCommand;
import org.drools.runtime.rule.QueryResults;
import org.drools.mas.Act;
import org.drools.mas.body.content.*;
import org.drools.mas.body.acts.*;
import org.drools.mas.util.MessageContentHelper;
import org.drools.mas.util.MessageContentFactory;

import java.util.List;
import java.util.ArrayList;

import org.slf4j.Logger;

//Global Logger
global Logger logger;


rule "Invoke"
when
    $msg : ACLMessage( $msgId : id )
    $dst : Destination( $msgId , $sessionId ; )
    $cmd : MessageCommands( $msgId, $batch ; )
then
    if (logger.isTraceEnabled()) {
        logger.trace(" ### INTERNAL: EXECUTING msg commands for "+ $msgId + " in " + $sessionId);
        logger.trace(" ### INTERNAL: \t commands " + $cmd);
    }
    retract($dst);
    retract($cmd);

    StatefulKnowledgeSession kSession = (StatefulKnowledgeSession) proxies.get($sessionId);
    Object retVal = null;

    try {
        org.drools.runtime.impl.ExecutionResultImpl result = (org.drools.runtime.impl.ExecutionResultImpl) kSession.execute($batch);
        retVal = result.getValue("$out_"+$msgId);
    } catch ( Exception e ) {
        insert( new PerformativeFail( $msgId, e.getMessage() ) );
    }

    ResponseContent response = new ResponseContent($msgId, retVal );
    insert( response );


end


rule "Invoke_OneShot"
salience 1
when
    $msg : ACLMessage( $msgId : id )
    $dst : Destination( $msgId , $sessionId ; )
    $cmd : OneShotMessageCommand( $msgId, $act ; )
then
    if (logger.isTraceEnabled()) {
        logger.trace(" ### INTERNAL: EXECUTING msg command ONE for "+ $msgId + " in " + $sessionId);
        logger.trace(" ### INTERNAL: \t commands " + $cmd);
    }
    retract($cmd);
    StatefulKnowledgeSession kSession = (StatefulKnowledgeSession) proxies.get($sessionId);

    kSession.execute($act);
    kSession.execute(CommandFactory.newFireAllRules());
end


// Process Performatives 


rule "Process_Inform"
when
    $msg : ACLMessage( $msgId : id, performative == Act.INFORM )
    Inform( $info : proposition ) from $msg.body
    $dst : Destination( $msgId ; )
then
    if (logger.isTraceEnabled()) {
        logger.trace(" ### INTERNAL: GENERATING COMMANDS FOR INFORM " + $msgId );
    }
    List list = new ArrayList(2);
            list.add(CommandFactory.newInsert( $info.getData(), "$out_"+$msgId ));
            list.add(CommandFactory.newFireAllRules());
    BatchExecutionCommand batch = CommandFactory.newBatchExecution(list);
    insert( new MessageCommands( $msgId, batch ) );
end





rule "Process_QueryIf"
when
    $msg : ACLMessage( $msgId : id, performative == Act.QUERY_IF )
    QueryIf( $info : proposition ) from $msg.body
    $dst : Destination( $msgId ; )
then
    if (logger.isTraceEnabled()) {
        logger.trace(" ### INTERNAL: GENERATING COMMANDS FOR QUERYIF " + $msgId );
    }
    List list = new ArrayList(1);
            list.add(CommandFactory.newQuery( "$out_"+$msgId, "queryIf", new Object[] {$info.getData()} ));
    BatchExecutionCommand batch = CommandFactory.newBatchExecution(list);
    insert( new MessageCommands( $msgId, batch ) );
end


rule "Fix_QueryIf_Results"
salience 9999
no-loop
when
    $msg :  ACLMessage( $msgId : id, performative == Act.QUERY_IF )
    $cont : ResponseContent( messageId == $msgId, $data : data != null )
            QueryResults( size > 0 ) from $data
then
    if (logger.isTraceEnabled()) {
        logger.trace(" ### INTERNAL: FIXING QUERYIF RESULTS " + $msgId );
    }
    $cont.setData(((QueryResults) $data).iterator().next().get("$queryIf"));
    update($cont);
end






rule "Process_QueryRef"
when
    $msg : ACLMessage( $msgId : id, performative == Act.QUERY_REF )
    QueryRef( $query : query ) from $msg.body
    $dst : Destination( $msgId ; )
then
    if (logger.isTraceEnabled()) {
        logger.trace(" ### INTERNAL: GENERATING COMMANDS FOR QUERYREF " + $msgId);
    }
    List list = new ArrayList(2);
            list.add(CommandFactory.newQuery( "$out_"+$msgId, $query.getQueryName() , $query.getArgs().toArray() ));
    BatchExecutionCommand batch = CommandFactory.newBatchExecution(list);
    insert( new MessageCommands( $msgId, batch ) );
end


rule "Fix_QueryRef_Results"
salience 9999
no-loop
when
    $msg : ACLMessage( $msgId : id, performative == Act.QUERY_REF )
    QueryRef( $query : query ) from $msg.body
    $cont : ResponseContent( messageId == $msgId, $data : data != null )
then
    if (logger.isTraceEnabled()) {
        logger.trace(" ### INTERNAL: FIXING RESULTS FOR QUERYREF " + $msgId);
    }
    $cont.setData(MessageContentHelper.getQueryReferences($query, (QueryResults) $data));
    update($cont);
end



rule "Process_Request"
when
    $msg : ACLMessage( $msgId : id, performative == Act.REQUEST )
    $req : Request( $act : action, $actName : action.actionName ) from $msg.body
    $dst : Destination( $msgId ; )
then
    if (logger.isTraceEnabled()) {
        logger.trace(" ### INTERNAL: GENERATING COMMANDS FOR REQUEST " + $msgId);
    }
    List list = new ArrayList(3);
            list.add(CommandFactory.newInsert( $req.getAction() ));
            list.add(CommandFactory.newFireAllRules());
            
            list.add(CommandFactory.newQuery( "$out_"+$msgId, $act.getActionName() , MessageContentHelper.getActionArgsArray( $req.getAction() ) ) );
    BatchExecutionCommand batch = CommandFactory.newBatchExecution(list);
    insert( new MessageCommands( $msgId, batch ) );
end


rule "Fix_Request_Results"
salience 9999
no-loop
when
    $msg : ACLMessage( $msgId : id, performative == Act.REQUEST )
    $req : Request( $act : action, $actName : action.actionName ) from $msg.body
    $cont : ResponseContent( messageId == $msgId, $data : data != null )
then
    if (logger.isTraceEnabled()) {
        logger.trace(" ### INTERNAL: FIXING RESULTS FOR REQUEST " + $msgId);
    }
    $cont.setData( MessageContentHelper.getActionReferences($act, (QueryResults) $data));
    update($cont);
end


rule "Process_Request_When"
when
    $msg : ACLMessage( $msgId : id, performative == Act.REQUEST_WHEN )
    $req : RequestWhen( $act : action, $actName : action.actionName, $condition : condition.drl ) from $msg.body
    $dst : Destination( $msgId ; )
then
    if (logger.isTraceEnabled()) {
        logger.trace(" ### INTERNAL: GENERATING COMMANDS FOR REQUEST WHEN " + $msgId + " " + $condition);
    }
    ActionHolder holder = new ActionHolder($msgId, $act, $condition, false);

    insert( new OneShotMessageCommand( $msgId,  CommandFactory.newInsert( holder ) ) );

    java.util.List list = new ArrayList(1);
              list.add(CommandFactory.newFireAllRules());
//            list.add(CommandFactory.newQuery( "$out_"+$msgId, $act.getActionName() , $act.getArgsArray()) );
    BatchExecutionCommand batch = CommandFactory.newBatchExecution(list);
    insert( new MessageCommands( $msgId, batch ) );


end


rule "Process_Request_Whenever"
when
    $msg : ACLMessage( $msgId : id, performative == Act.REQUEST_WHENEVER )
    $req : RequestWhenever( $act : action, $actName : action.actionName, $condition : condition.drl ) from $msg.body
    $dst : Destination( $msgId ; )
then
    if (logger.isTraceEnabled()) {
        logger.trace(" ### INTERNAL: GENERATING COMMANDS FOR REQUEST WHENEVER " + $msgId + " " + $condition);
    }
    ActionHolder holder = new ActionHolder($msgId, $act, $condition, true);

    insert( new OneShotMessageCommand( $msgId,  CommandFactory.newInsert( holder ) ) );

    java.util.List list = new ArrayList(1);
              list.add(CommandFactory.newFireAllRules());
//            list.add(CommandFactory.newQuery( "$out_"+$msgId, $act.getActionName() , $act.getArgsArray()) );
    BatchExecutionCommand batch = CommandFactory.newBatchExecution(list);
    insert( new MessageCommands( $msgId, batch ) );
end


rule "Failed_Results"
salience 9999
no-loop
when
    $msg : ACLMessage( $msgId : id, performative == Act.REQUEST || == Act.REQUEST_WHEN || == Act.REQUEST_WHENEVER )
    $req : Request( $act : action, $actName : action.actionName ) from $msg.body
    $cnt : ResponseContent( messageId == $msgId, $data : data == null )
    not    PerformativeFail( messageId == $msgId )
    // no exception thrown (so no failure is already in), but still the request did not return anything
then
   PerformativeFail fail = new PerformativeFail( $msgId,  $actName + " : No result is returned" );
   if (logger.isTraceEnabled()) {
       logger.trace(" ### INTERNAL: FAILURE -> "+ fail);
   }
   insert( fail );
end




